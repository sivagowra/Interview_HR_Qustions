<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Full Notes and Advanced Concepts</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background-color: #f0f2f5; color: #333; line-height: 1.6; }
        h1 { color: #007bff; text-align: center; border-bottom: 4px solid #007bff; padding-bottom: 10px; margin-bottom: 30px; }
        h2 { color: #28a745; border-bottom: 2px solid #ccc; padding-bottom: 5px; margin-top: 30px; }
        h3 { color: #6c757d; margin-top: 20px; }
        p { margin-bottom: 15px; }
        ul { list-style-type: disc; margin-left: 20px; margin-bottom: 15px; }
        li { margin-bottom: 5px; }
        table { width: 100%; margin: 20px 0; border-collapse: collapse; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; vertical-align: top; }
        th { background-color: #e9ecef; color: #495057; text-transform: uppercase; font-size: 0.9em; }
        tr:nth-child(even) { background-color: #f8f8f8; }
        .command { font-family: 'Courier New', Courier, monospace; color: #dc3545; padding: 2px 4px; border-radius: 3px; background-color: #fff0f0; white-space: pre-wrap; display: block; }
        .concept-text strong { color: #007bff; }
    </style>
</head>
<body>
    <h1>DOCKER FULL NOTES AND ADVANCED CONCEPTS</h1>

    <h2>Introduction and Need for Docker</h2>

    <h3>Monolithic Architecture</h3>
    <div class="concept-text">
        <p>If an application contains <strong>N number of services</strong> (e.g., Paytm has Money Transactions, Movie Tickets, Train tickets, etc.) and all these services are <strong>included in one server</strong>, then it is called Monolithic Architecture. Every monolithic Architecture has <strong>only one database</strong> for all the services.</p>
    </div>

    <h3>Micro Services Architecture</h3>
    <div class="concept-text">
        <p>If an application contains <strong>N number of services</strong> and <strong>every service has its own individual servers</strong>, then it is called microservices. Every microservice architecture has its <strong>own database for each service</strong>. </p>
    </div>

    <h3>Why Docker (The Problem)</h3>
    <div class="concept-text">
        <p>When developing an application, we need to install dependencies (e.g., Java11, ReactJS, MongoDB) to run the code. If a developer later needs another version of Java, React, or MongoDB for a different application, it becomes a <strong>hectic situation to maintain multiple versions of the same tool</strong> in one system. To overcome this problem, we use virtualization/containerization.</p>
    </div>

    <h2>Virtualization vs. Containerization</h2>

    <h3>Virtualization</h3>
    <div class="concept-text">
        <p>Used to create **Virtual Machines (VMs)** inside a machine. In these VMs, we can host **Guest OS** in our machine. **Hypervisor** is used to create the virtualization. By using a Guest OS, we can run multiple applications on the same machine. </p>
        <p><strong>Drawbacks:</strong></p>
        <ul>
            <li>It is an old method.</li>
            <li>If we use multiple Guest OS, the <strong>performance of the system is low</strong>.</li>
        </ul>
    </div>

    <h3>Containerization and Container</h3>
    <div class="concept-text">
        <ul>
            <li><strong>Containerization:</strong> Used to <strong>pack the application along with its dependencies</strong> to run the application.</li>
            <li><strong>Container:</strong> It is a virtual machine which <strong>does not have any OS</strong>.</li>
            <li><strong>Docker is used to create these containers.</strong> </li>
        </ul>
    </div>

    <h3>Docker Definition</h3>
    <div class="concept-text">
        <ul>
            <li>Docker is an <strong>open-source centralized platform</strong> designed to create, deploy, and run applications.</li>
            <li>It is written in the <strong>Go language</strong>.</li>
            <li>Docker uses containers on a host OS to run applications. It allows applications to use the <strong>same Linux kernel</strong> as the host, rather than creating a whole virtual OS.</li>
            <li>Docker performs <strong>OS level Virtualization</strong>, also known as <strong>Containerization</strong>.</li>
            <li>A key benefit: it solves the problem of "it works on my machine but not yours" by packaging the environment.</li>
            <li>Containers have OS files, but their size is negligible compared to the original files of that OS.</li>
        </ul>
    </div>

    <h2>Docker Architecture</h2>
    <div class="concept-text">
        <ul>
            <li><strong>Docker Client:</strong> The primary way users interact with Docker. It sends commands (like `docker run`) to the Docker Daemon via the Docker API.</li>
            <li><strong>Docker Host:</strong> The machine where the Docker engine is installed.</li>
            <li><strong>Docker Daemon:</strong> Runs on the host OS. It is responsible for running containers and managing Docker services. It communicates with other daemons and manages Docker objects (images, containers, networking, storage).</li>
            <li><strong>Docker Registry:</strong> A scalable open-source storage and distribution system for Docker images. (e.g., Docker Hub).</li>
        </ul>
    </div>

    <h2>Basic Docker Commands (Lifecycle)</h2>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr><td><span class="command">yum install docker -y</span></td><td>To install docker in Linux.</td></tr>
            <tr><td><span class="command">docker --version</span></td><td>To see the docker version.</td></tr>
            <tr><td><span class="command">service docker start</span></td><td>To start the docker service.</td></tr>
            <tr><td><span class="command">service docker status</span></td><td>To check if the service is running.</td></tr>
            <tr><td><span class="command">docker info</span></td><td>To check the docker information.</td></tr>
            <tr><td><span class="command">docker images</span></td><td>To see all images in the local machine.</td></tr>
            <tr><td><span class="command">docker search image name</span></td><td>To find images in Docker Hub.</td></tr>
            <tr><td><span class="command">docker pull image name</span></td><td>To download an image from Docker Hub to local.</td></tr>
            <tr><td><span class="command">docker run -it image name /bin/bash</span></td><td>To download and run an image at a time.</td></tr>
            <tr><td><span class="command">docker run -it --name raham img-name /bin/bash</span></td><td>To give a name to a container.</td></tr>
            <tr><td><span class="command">docker start container name</span></td><td>To start a container.</td></tr>
            <tr><td><span class="command">docker attach container name</span></td><td>To go inside the container.</td></tr>
            <tr><td><span class="command">cat /etc/os-release</span></td><td>To see all the details inside the container.</td></tr>
            <tr><td><span class="command">exit</span></td><td>To get outside of the container.</td></tr>
            <tr><td><span class="command">docker ps -a</span></td><td>To see all containers.</td></tr>
            <tr><td><span class="command">docker ps (ps: process status)</span></td><td>To see only running containers.</td></tr>
        </tbody>
    </table>

    <h2>Alternate and Management Commands</h2>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr><td><span class="command">docker container ls</span></td><td>To see the list of containers.</td></tr>
            <tr><td><span class="command">docker container ls -a</span></td><td>To see all containers.</td></tr>
            <tr><td><span class="command">docker container ls -n 2</span></td><td>To see the latest 2 containers.</td></tr>
            <tr><td><span class="command">docker container ls --latest</span></td><td>To see the latest container.</td></tr>
            <tr><td><span class="command">docker ls -a -q</span></td><td>To see all container IDs.</td></tr>
            <tr><td><span class="command">docker container rm -f $(docker container ls -aq)</span></td><td>To remove all containers.</td></tr>
            <tr><td><span class="command">docker container ls -a -s</span></td><td>To see containers with sizes.</td></tr>
            <tr><td><span class="command">docker stop -t 60 cont_id</span></td><td>To stop a container after some time (graceful shutdown timeout).</td></tr>
            <tr><td><span class="command">docker rename old_container new_container</span></td><td>To rename a docker container.</td></tr>
            <tr><td><span class="command">docker export -o path container</span></td><td>Used to save the docker container to a tar file.</td></tr>
        </tbody>
    </table>

    <h2>Advanced Container Operations</h2>

    <h3>Run Container with Port Mapping and Limits</h3>
    <div class="concept-text">
        <p><strong>Port Mapping Example:</strong> To map host port 8081 to container port 80:</p>
        <span class="command">docker run --name cont2 -d -p 8081(hostport):80(container port) nginx</span>
        <p><strong>Setting Resource Limits:</strong> Used to set memory limits and CPU limits to containers.</p>
        <span class="command">docker run -dit --name cont_name --memory=250m --cpus="0.25" image_name</span>
        <p><strong>Docker Exec:</strong> Used to run commands inside a running container, or enter it:</p>
        <span class="command">docker exec -it cont_name /bin/bash</span>
    </div>

    <h3>Creating an Image from a Container</h3>
    <ol>
        <li>Create a container from a base image: <span class="command">docker run -it --name container_name image_name /bin/bash</span></li>
        <li>Make desired changes inside the container.</li>
        <li>Exit the container.</li>
        <li>Commit the changes to a new image: <span class="command">docker commit container_name new_image_name</span></li>
    </ol>

    <h2>Dockerfile Components</h2>
    <div class="concept-text">
        <p>A **Dockerfile** is a text file that contains a set of instructions used for the <strong>automation of Docker image creation</strong>. The 'D' in Dockerfile is always a capital letter, and the starting components are also capital letters.</p>
    </div>
    <table>
        <thead>
            <tr>
                <th>Component</th>
                <th>Description / Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr><td><span class="command">FROM</span></td><td>For the base image; this command must be on top of the file. (e.g., ubuntu, Redis, Jenkins)</td></tr>
            <tr><td><span class="command">LABEL</span></td><td>Labeling like EMAIL, AUTHOR, etc.</td></tr>
            <tr><td><span class="command">RUN</span></td><td>To <strong>execute commands while we build the image</strong> and adds a new layer into the image.</td></tr>
            <tr><td><span class="command">COPY</span></td><td>Copy files/folders from the local system (Docker VM) to the container. Requires Source and Destination.</td></tr>
            <tr><td><span class="command">ADD</span></td><td>Used to copy files, and it can also <strong>download files from the internet and extract them</strong> at the image side.</td></tr>
            <tr><td><span class="command">EXPOSE</span></td><td>To expose ports (e.g., 8080 for tomcat, 80 for nginx). For internal access.</td></tr>
            <tr><td><span class="command">WORKDIR</span></td><td>To set the working directory for the container.</td></tr>
            <tr><td><span class="command">CMD</span></td><td><strong>Executes commands during container creation.</strong> If multiple CMDs exist, only the last one is executed.</td></tr>
            <tr><td><span class="command">ENTRYPOINT</span></td><td>The command that executes inside a container. It overwrites the CMD when additional parameters are passed while running the container.</td></tr>
            <tr><td><span class="command">ENV</span></td><td>Environment Variables (accessible inside the container).</td></tr>
            <tr><td><span class="command">ARG</span></td><td>Used to pass build-time arguments (<strong>not available inside the container</strong>).</td></tr>
        </tbody>
    </table>

    <h2>Command Comparisons</h2>
    <table>
        <thead>
            <tr>
                <th>Comparison</th>
                <th>Command/Concept</th>
                <th>Key Difference</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>ENV vs ARG</strong></td>
                <td>ARG</td>
                <td>Argument is <strong>not available</strong> inside the Docker containers.</td>
            </tr>
            <tr>
                <td><strong>ENV vs ARG</strong></td>
                <td>ENV</td>
                <td>Argument is <strong>accessible</strong> inside the container.</td>
            </tr>
            <tr>
                <td><strong>RUN vs CMD vs ENTRYPOINT</strong></td>
                <td>RUN</td>
                <td>Used to execute commands <strong>while building the image</strong>.</td>
            </tr>
            <tr>
                <td><strong>RUN vs CMD vs ENTRYPOINT</strong></td>
                <td>CMD</td>
                <td>Used to execute commands <strong>when running the container</strong> (default command).</td>
            </tr>
            <tr>
                <td><strong>RUN vs CMD vs ENTRYPOINT</strong></td>
                <td>ENTRYPOINT</td>
                <td>Defines the main command; parameters passed during `docker run` are appended to it.</td>
            </tr>
            <tr>
                <td><strong>COPY vs ADD</strong></td>
                <td>COPY</td>
                <td>Used to copy local files to containers.</td>
            </tr>
            <tr>
                <td><strong>COPY vs ADD</strong></td>
                <td>ADD</td>
                <td>Used to copy files, can also <strong>download and extract</strong> files from the internet.</td>
            </tr>
            <tr>
                <td><strong>STOP vs KILL</strong></td>
                <td>STOP</td>
                <td>Attempts to gracefully shutdown (issues a <strong>SIGTERM</strong> signal).</td>
            </tr>
            <tr>
                <td><strong>STOP vs KILL</strong></td>
                <td>KILL</td>
                <td>Immediately stops/terminates (issues a <strong>SIGKILL</strong> signal).</td>
            </tr>
        </tbody>
    </table>

    <h2>Docker Volumes</h2>
    <div class="concept-text">
        <p>Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.</p>
        <p><strong>Uses:</strong> Decoupling Container from storage, sharing volumes among different containers, and the volume <strong>will not be deleted</strong> when the container is deleted.</p>
        <h3>Creating/Sharing Volumes (Command Line)</h3>
        <ol>
            <li>Create container with a volume: <span class="command">docker run -it --name container3 -v /volume2 ubuntu /bin/bash</span></li>
            <li>Share the volume with a new container: <span class="command">docker run -it --name container4 --privileged=true --volumes-from container3 ubuntu</span> (Now `volume2` is visible in `container4`).</li>
        </ol>
        <h3>Mount Volumes</h3>
        <ol>
            <li>Create a volume: <span class="command">docker volume create volume99</span></li>
            <li>Mount it to a container: <span class="command">docker run -it -v volume99:/my-volume --name container1 ubuntu</span></li>
            <li>To remove a volume: <span class="command">docker volume rm volume_name</span></li>
            <li>To remove all unused volumes: <span class="command">docker volume prune</span></li>
        </ol>
    </div>

    <h2>Docker Registry and Hub</h2>
    <div class="concept-text">
        <p>A Docker Registry is used to <strong>store the images</strong>. Docker Hub is the default public registry. Other registries include:</p>
        <ul>
            <li>Cloud based registries (GCR, Amazon ECR)</li>
            <li>Local registry, Nexus, Jfrog, DTR (Docker Trusted Registry)</li>
        </ul>
        <p><strong>Docker Push Steps:</strong></p>
        <ol>
            <li>Log in: <span class="command">docker login</span></li>
            <li>Tag the image (required for push): <span class="command">docker tag image1 rahamshaik007/image1:latest</span></li>
            <li>Push the image: <span class="command">docker push rahamshaik007/image1:latest</span></li>
        </ol>
    </div>

    <h2>Docker Networking</h2>
    <div class="concept-text">
        <p>The IP address of a container is <strong>not permanent</strong>. If a container is removed and recreated, it gets a new IP, causing connection issues. To resolve this, **Docker Networks** are used to create custom networks, allowing containers to communicate using their names instead of IPs.</p>
        <ul>
            <li>To create a network: <span class="command">docker network create network_name</span></li>
            <li>To connect a container: <span class="command">docker network connect network_name container_id/name</span></li>
        </ul>
    </div>

    <h2>Docker Swarm (Orchestration)</h2>
    <div class="concept-text">
        <p>Docker Swarm is an orchestration service within Docker that allows managing and handling multiple containers across a **cluster of servers** at the same time. </p>
        <ul>
            <li>The cluster's activities are controlled by a **Swarm Manager**.</li>
            <li>Machines that join the cluster are called **Swarm Workers**.</li>
            <li>To initialize the manager: <span class="command">docker swarm init --advertise-addr (private ip)</span></li>
            <li>To see nodes: <span class="command">docker node ls</span></li>
        </ul>
        <h3>Services and Scaling in Swarm</h3>
        <p>The **Docker Service** command is used to run a specific container (or replica set) on all nodes.</p>
        <ul>
            <li>Create a service (3 replicas): <span class="command">docker service create --name raham --replicas 3 --publish 80:80 httpd</span></li>
            <li>Scale a service: <span class="command">docker service scale service_name=5</span></li>
            <li>Remove a service: <span class="command">docker service rm service_name</span></li>
        </ul>
    </div>

    <h2>Docker Compose (Multi-Container Management)</h2>
    <div class="concept-text">
        <p>Docker Compose is a tool used to build, run, and ship <strong>multiple containers for an application on a single host</strong>.</p>
        <ul>
            <li>It uses a **YAML file** (`docker-compose.yml`) to manage multi-containers as a single service, defining services, networks, and volumes.</li>
            <li>Start all services: <span class="command">docker-compose up</span></li>
            <li>Run in detached mode: <span class="command">docker-compose up -d</span></li>
            <li>Stop and remove all containers: <span class="command">docker-compose down</span></li>
            <li>Run a file with a non-default name: <span class="command">docker-compose -f docker-compose1.yml up -d</span></li>
        </ul>
        <p><strong>Docker Stack</strong> is used to deploy multi-container applications (defined in a Compose file) across <strong>multiple hosts</strong> within a Docker Swarm cluster.</p>
    </div>



    <h1>Docker Volume & Container Sharing</h1>

<div class="box">
    <h2>1️⃣ Volume to Containers Share</h2>
    <pre><code>docker volume create myvolume
docker volume ls

docker run -d --name website1 -p 8001:80 \
-v myvolume:/usr/share/nginx/html sivagowra/web

docker run -d --name website2 -p 8002:80 \
--privileged --volumes-from website1 sivagowra/web
</code></pre>
</div>

<div class="box">
    <h2>2️⃣ Host to Container Share</h2>
    <pre><code>(pwd mandatory)
docker run -d --name website1 -p 8011:80 \
-v $(pwd):/usr/share/nginx/html nginx
</code></pre>
</div>

<div class="box">
    <h2>3️⃣ Volume to Container (Using --mount)</h2>
    <pre><code>docker run -d --name web -p 8012:80 \
--mount source=myvolume,destination=/usr/share/nginx/html nginx
</code></pre>
</div>


<div class="docker-guide">

  <div class="section">
    <h2>Docker Runtime & Inspection Commands</h2>
    <p>This guide explains commonly used Docker commands with purpose and real-world usage.</p>
  </div>

  <div class="section">
    <h3>1️⃣ docker export</h3>
    <p><strong>Purpose:</strong> Take a snapshot of a container’s filesystem and save it as a .tar file.</p>
    <ul>
      <li>Backup container files</li>
      <li>Migrate container data</li>
      <li>Create a clean filesystem snapshot</li>
    </ul>
    <p><strong>Example:</strong></p>
    <pre>docker export siva -o siva_fs.tar</pre>
  </div>

  <div class="section">
    <h3>2️⃣ docker stats</h3>
    <p><strong>Purpose:</strong> Live monitoring of container resource usage.</p>
    <ul>
      <li>CPU usage</li>
      <li>Memory usage</li>
      <li>Network I/O</li>
      <li>Disk I/O</li>
    </ul>
    <pre>docker stats</pre>
  </div>

  <div class="section">
    <h3>3️⃣ docker top</h3>
    <p><strong>Purpose:</strong> Show running processes inside a container.</p>
    <pre>docker top siva</pre>
    <p>Useful for checking if application processes are running correctly.</p>
  </div>

  <div class="section">
    <h3>4️⃣ docker attach</h3>
    <p><strong>Purpose:</strong> Attach your terminal to a container’s STDOUT/STDIN.</p>
    <pre>docker attach siva</pre>
    <p><strong>Warning:</strong> Pressing Ctrl+C will stop the container.</p>
  </div>

  <div class="section">
    <h3>5️⃣ docker wait</h3>
    <p><strong>Purpose:</strong> Wait until a container stops and return its exit code.</p>
    <pre>docker wait siva</pre>
    <p>Commonly used in automation and CI/CD pipelines.</p>
  </div>

  <div class="section">
    <h2>Comparison Tables</h2>
  </div>

  <div class="section">
    <h3>save vs export</h3>
    <table border="1" cellpadding="8">
      <tr>
        <th>docker save</th>
        <th>docker export</th>
      </tr>
      <tr>
        <td>Exports Docker image</td>
        <td>Exports running container filesystem</td>
      </tr>
      <tr>
        <td>Preserves image layers & metadata</td>
        <td>No layers or metadata</td>
      </tr>
      <tr>
        <td>Used for image migration</td>
        <td>Used for filesystem backup</td>
      </tr>
      <tr>
        <td>Works with images</td>
        <td>Works with containers</td>
      </tr>
    </table>
  </div>

  <div class="section">
    <h3>attach vs exec</h3>
    <table border="1" cellpadding="8">
      <tr>
        <th>docker attach</th>
        <th>docker exec</th>
      </tr>
      <tr>
        <td>Connects to main process</td>
        <td>Runs a new command inside container</td>
      </tr>
      <tr>
        <td>Ctrl+C stops container</td>
        <td>Ctrl+C does NOT stop container</td>
      </tr>
      <tr>
        <td>Used for debugging output</td>
        <td>Used for admin/debug tasks</td>
      </tr>
      <tr>
        <td>Risky for production</td>
        <td>Safe for production</td>
      </tr>
    </table>
  </div>

  <div class="section">
    <h3>Best Practices</h3>
    <ul>
      <li>Use <strong>docker logs -f</strong> instead of attach</li>
      <li>Use <strong>docker exec -it</strong> for shell access</li>
      <li>Monitor containers using <strong>docker stats</strong></li>
    </ul>
  </div>

</div>
<div class="docker-export-guide">

  <div class="section">
    <h2>Docker Export File Location</h2>
    <p>
      When you run the following command:
    </p>
    <pre>docker export siva -o siva_fs.tar</pre>
    <p>
      The file <strong>siva_fs.tar</strong> is saved in your <strong>current working directory</strong>.
    </p>
  </div>

  <div class="section">
    <h3>How to check current directory</h3>
    <pre>pwd</pre>
    <p>
      Example output:
    </p>
    <pre>/root</pre>
    <p>
      File location will be:
      <br>
      <strong>/root/siva_fs.tar</strong>
    </p>
  </div>

  <div class="section">
    <h3>Verify the file exists</h3>
    <pre>ls -lh siva_fs.tar</pre>
    <pre>ls -lh *.tar</pre>
  </div>

  <div class="section">
    <h3>Search file if location is unknown</h3>
    <pre>find / -name siva_fs.tar 2>/dev/null</pre>
  </div>

  <div class="section">
    <h2>How to Open the Exported tar File</h2>
  </div>

  <div class="section">
    <h3>View contents without extracting</h3>
    <pre>tar -tf siva_fs.tar</pre>
    <pre>tar -tf siva_fs.tar | less</pre>
  </div>

  <div class="section">
    <h3>Extract the tar file</h3>
    <pre>mkdir siva_fs</pre>
    <pre>tar -xf siva_fs.tar -C siva_fs</pre>
    <pre>cd siva_fs</pre>
    <pre>ls</pre>
  </div>

  <div class="section">
    <h3>Common nginx website file location</h3>
    <pre>usr/share/nginx/html/</pre>
    <pre>cat index.html</pre>
    <pre>vi index.html</pre>
  </div>

  <div class="section">
    <h2>Import tar File as Docker Image</h2>
    <pre>cat siva_fs.tar | docker import - siva:backup</pre>
  </div>

  <div class="section">
    <h3>Error while running container</h3>
    <pre>docker run -d -p 8081:80 siva:backup</pre>
    <p><strong>Error:</strong> no command specified</p>
  </div>

  <div class="section">
    <h3>Why this error occurs</h3>
    <p>
      <strong>docker import</strong> only imports filesystem data.
      It does NOT include:
    </p>
    <ul>
      <li>CMD</li>
      <li>ENTRYPOINT</li>
      <li>EXPOSE</li>
    </ul>
  </div>

  <div class="section">
    <h3>Fix – specify command manually</h3>
    <pre>docker run -d -p 8081:80 siva:backup nginx -g "daemon off;"</pre>
  </div>

  <div class="section">
    <h3>Best Fix – add CMD while importing</h3>
    <pre>
cat siva_fs.tar | docker import \
-c 'CMD ["nginx","-g","daemon off;"]' \
-c 'EXPOSE 80' \
siva:backup
    </pre>
  </div>

  <div class="section">
    <h3>Verify CMD</h3>
    <pre>docker inspect siva:backup | grep -A5 Cmd</pre>
  </div>

  <div class="section">
    <h2>Key Differences</h2>
    <table border="1" cellpadding="8">
      <tr>
        <th>docker save</th>
        <th>docker export</th>
      </tr>
      <tr>
        <td>Exports image with metadata</td>
        <td>Exports container filesystem only</td>
      </tr>
      <tr>
        <td>Preserves CMD & layers</td>
        <td>No CMD or layers</td>
      </tr>
      <tr>
        <td>Used for image backup</td>
        <td>Used for filesystem backup</td>
      </tr>
    </table>
  </div>

</div>
<div class="nginx-log-guide">

  <div class="section">
    <h2>Nginx Log Directory Explanation</h2>
    <p>
      You are currently inside the Nginx log directory:
    </p>
    <pre>/var/log/nginx/</pre>
  </div>

  <div class="section">
    <h3>Files Present in the Directory</h3>
    <pre>
access.log
access.log-20260129
error.log
error.log-20260129
    </pre>
  </div>

  <div class="section">
    <h3>access.log</h3>
    <p>
      This file records <strong>all incoming requests</strong> to the Nginx server.
    </p>
    <ul>
      <li>Client IP address</li>
      <li>Requested URL</li>
      <li>HTTP status code</li>
      <li>Browser details</li>
    </ul>
    <p><strong>Use cases:</strong></p>
    <ul>
      <li>Monitor website traffic</li>
      <li>Debug 404 / 403 issues</li>
    </ul>
  </div>

  <div class="section">
    <h3>error.log</h3>
    <p>
      This file stores <strong>Nginx errors and warnings</strong>.
    </p>
    <p><strong>Common errors logged:</strong></p>
    <ul>
      <li>Missing files (404)</li>
      <li>Permission denied</li>
      <li>Configuration issues</li>
    </ul>
  </div>

  <div class="section">
    <h3>access.log-20260129</h3>
    <p>
      This is an <strong>older access log file</strong> created by log rotation.
    </p>
    <p>
      Date indicates when the log was archived.
    </p>
  </div>

  <div class="section">
    <h3>error.log-20260129</h3>
    <p>
      This is an <strong>previous error log file</strong> stored for historical reference.
    </p>
  </div>

  <div class="section">
    <h2>Why Do Date-Based Log Files Exist?</h2>
    <p>
      Linux uses a process called <strong>log rotation</strong> to prevent log files from growing too large.
    </p>
    <p>
      New logs go into current files, while old logs are archived with a date suffix.
    </p>
  </div>

  <div class="section">
    <h2>How to Read Nginx Logs</h2>
    <p><strong>View latest access logs:</strong></p>
    <pre>tail access.log</pre>

    <p><strong>Watch logs live:</strong></p>
    <pre>tail -f access.log</pre>

    <p><strong>Check error logs:</strong></p>
    <pre>tail -f error.log</pre>
  </div>

  <div class="section">
    <h2>Simple Understanding</h2>
    <table border="1" cellpadding="8">
      <tr>
        <th>Log File</th>
        <th>Meaning</th>
      </tr>
      <tr>
        <td>access.log</td>
        <td>Visitor entry register</td>
      </tr>
      <tr>
        <td>error.log</td>
        <td>Problem complaint book</td>
      </tr>
      <tr>
        <td>*-date</td>
        <td>Old records kept for reference</td>
      </tr>
    </table>
  </div>

  <div class="section">
    <h2>Connection with Docker</h2>
    <p>
      When Nginx runs inside a Docker container, these logs record container traffic and errors.
    </p>
    <p>
      Missing files like <strong>favicon.ico</strong> are logged in <strong>error.log</strong>.
    </p>
  </div>

</div>

<div class="nginx-file-structure-guide">

  <div class="section">
    <h2>Nginx File & Directory Structure – Complete Explanation</h2>
    <p>
      Nginx uses a structured directory layout to manage configuration, websites,
      logs, and runtime behavior. Each directory has a specific role.
    </p>
  </div>

  <!-- nginx.conf -->
  <div class="section">
    <h3>/etc/nginx/nginx.conf</h3>
    <p>
      This is the <strong>main configuration file</strong> of Nginx.
      Every Nginx process starts by reading this file.
    </p>

    <p><strong>Main responsibilities:</strong></p>
    <ul>
      <li>Define global settings</li>
      <li>Control worker processes</li>
      <li>Include other configuration files</li>
      <li>Set logging behavior</li>
    </ul>

    <p><strong>Key sections inside nginx.conf:</strong></p>
    <ul>
      <li><strong>events { }</strong> – connection handling</li>
      <li><strong>http { }</strong> – web server configuration</li>
      <li><strong>include</strong> – load virtual host configs</li>
    </ul>

    <pre>
user nginx;
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
    </pre>

    <p>
      ⚠️ You usually do <strong>NOT</strong> put website configs directly here.
    </p>
  </div>

  <!-- sites-available -->
  <div class="section">
    <h3>/etc/nginx/sites-available/</h3>
    <p>
      This directory stores <strong>all website (virtual host) configuration files</strong>.
    </p>

    <p><strong>Purpose:</strong></p>
    <ul>
      <li>Keep website configs safely stored</li>
      <li>Allow enabling/disabling sites easily</li>
      <li>Prevent accidental activation</li>
    </ul>

    <p><strong>Example file:</strong></p>
    <pre>/etc/nginx/sites-available/example.com</pre>

    <p>
      Files here are <strong>NOT active</strong> by default.
    </p>
  </div>

  <!-- sites-enabled -->
  <div class="section">
    <h3>/etc/nginx/sites-enabled/</h3>
    <p>
      This directory contains <strong>symbolic links</strong> to files in
      <code>sites-available</code>.
    </p>

    <p><strong>Purpose:</strong></p>
    <ul>
      <li>Activate websites</li>
      <li>Control which sites Nginx serves</li>
    </ul>

    <p><strong>How a site is enabled:</strong></p>
    <pre>
ln -s /etc/nginx/sites-available/example.com \
      /etc/nginx/sites-enabled/example.com
    </pre>

    <p>
      When Nginx reloads, it reads only configs present here.
    </p>
  </div>

  <!-- var/www/html -->
  <div class="section">
    <h3>/var/www/html/</h3>
    <p>
      This is the <strong>default web root directory</strong>.
      Website files live here.
    </p>

    <p><strong>Contains:</strong></p>
    <ul>
      <li>HTML files</li>
      <li>CSS, JavaScript</li>
      <li>Images</li>
      <li>PHP files (with PHP-FPM)</li>
    </ul>

    <p><strong>Example:</strong></p>
    <pre>
/var/www/html/index.html
/var/www/html/style.css
    </pre>

    <p>
      This path is referenced using the <strong>root</strong> directive
      inside site config.
    </p>

    <pre>
root /var/www/html;
index index.html;
    </pre>
  </div>

  <!-- var/log/nginx -->
  <div class="section">
    <h3>/var/log/nginx/</h3>
    <p>
      This directory stores <strong>Nginx log files</strong>.
      Logs are critical for debugging and monitoring.
    </p>

    <p><strong>Main log files:</strong></p>
    <ul>
      <li><strong>access.log</strong> – all incoming requests</li>
      <li><strong>error.log</strong> – errors & warnings</li>
    </ul>

    <p><strong>Example logs:</strong></p>
    <pre>
49.207.216.130 - - "GET / HTTP/1.1" 200
open() "/usr/share/nginx/html/favicon.ico" failed
    </pre>

    <p><strong>Log rotation:</strong></p>
    <ul>
      <li>Old logs saved with date</li>
      <li>Prevents disk overflow</li>
    </ul>
  </div>

  <!-- Flow -->
  <div class="section">
    <h2>How Everything Works Together</h2>
    <ol>
      <li>Nginx starts → reads <strong>nginx.conf</strong></li>
      <li>nginx.conf includes <strong>sites-enabled</strong></li>
      <li>sites-enabled links configs from <strong>sites-available</strong></li>
      <li>Config points to files in <strong>/var/www/html</strong></li>
      <li>Requests & errors logged in <strong>/var/log/nginx</strong></li>
    </ol>
  </div>

  <!-- Summary -->
  <div class="section">
    <h2>Quick Summary Table</h2>
    <table border="1" cellpadding="8">
      <tr>
        <th>Path</th>
        <th>Purpose</th>
      </tr>
      <tr>
        <td>/etc/nginx/nginx.conf</td>
        <td>Main Nginx configuration</td>
      </tr>
      <tr>
        <td>/etc/nginx/sites-available</td>
        <td>Stored website configs</td>
      </tr>
      <tr>
        <td>/etc/nginx/sites-enabled</td>
        <td>Active website configs</td>
      </tr>
      <tr>
        <td>/var/www/html</td>
        <td>Website files</td>
      </tr>
      <tr>
        <td>/var/log/nginx</td>
        <td>Access & error logs</td>
      </tr>
    </table>
  </div>

</div>



</body>
</html>